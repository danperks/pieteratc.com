<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="https://fly.pieter.com/assets/fly_emoji.png">
    <title>Levelsio ATC Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background-color: #0a0a0a;
            color: #00ff00;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #title-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            display: flex;
            align-items: center;
        }
        
        #launch-button {
            margin-left: 15px;
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        #launch-button:hover {
            background-color: #004400;
        }
        
        #credits {
            position: absolute;
            top: 80px;
            left: 20px;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            font-size: 14px;
            z-index: 100;
            display: flex;
            align-items: center;
        }
        
        #cursor-logo {
            height: 20px;
            margin-left: 10px;
        }
        
        .clickable-text {
            position: relative;
            cursor: pointer;
            color: #00ff00;
            text-decoration: none;
            padding-bottom: 2px;
            margin: 0 3px;
            display: inline-block;
            padding-right: 15px;
            margin-left: 10px;
        }
        
        .clickable-text::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: calc(100% - 15px);
            border-bottom: 1px solid #00ff0078;
        }
        
        .clickable-text::before {
            content: "â†—";
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 17px;
            opacity: 0.8;
        }
        
        .clickable-text:hover {
            color: #ffff00;
        }
        
        .clickable-text:hover::after {
            border-bottom-color: #ffff00;
        }
        
        .clickable-text:hover::before {
            color: #ffff00;
        }
        
        #connection-status {
            position: absolute;
            top: 120px;
            left: 12px;
            padding: 8px 12px;
            font-size: 14px;
            z-index: 100;
            display: none; /* Hide the standalone connection status */
        }
        
        #radar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vmin;
            height: 80vmin;
            border-radius: 50%;
            background-color: #001100;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            overflow: hidden;
        }
        
        .radar-sweep {
            position: absolute;
            top: 0;
            left: 50%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, rgba(0,255,0,0) 0%, rgba(0,255,0,0.2) 100%);
            transform-origin: left center;
            animation: sweep 5s infinite linear;
        }
        
        @keyframes sweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .radar-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
        }
        
        .radar-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .plane {
            position: absolute;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: transform 0.5s ease-out, opacity 0.5s ease-out;
            z-index: 10;
        }
        
        .plane-icon {
            width: 100%;
            height: 100%;
            fill: #00ff00;
            transform-origin: center;
            filter: drop-shadow(0 0 2px rgba(0, 255, 0, 0.7));
        }
        
        /* Altitude-based colors */
        .altitude-low .plane-icon {
            fill: #00ff00; /* Green for low altitude */
        }
        
        .altitude-medium .plane-icon {
            fill: #ffff00; /* Yellow for medium altitude */
        }
        
        .altitude-high .plane-icon {
            fill: #ff00ff; /* Magenta for high altitude */
        }
        
        .altitude-very-high .plane-icon {
            fill: #00ffff; /* Cyan for very high altitude */
        }
        
        .plane-label {
            position: absolute;
            top: -20px;
            left: 10px;
            font-size: 12px;
            white-space: nowrap;
            color: #00ff00;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .plane:hover .plane-label {
            opacity: 1;
        }
        
        .plane-trail {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
        }
        
        /* New trail line style */
        .trail-line {
            position: absolute;
            height: 1px;
            background-color: rgba(0, 255, 0, 0.4);
            transform-origin: left center;
            z-index: 5;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 15px;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        #selected-plane-info {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 0, 0.3);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .info-label {
            color: rgba(0, 255, 0, 0.7);
        }
        
        .info-value {
            font-weight: bold;
        }
        
        #controls {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 8px;
            z-index: 90;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
        }
        
        button {
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            margin: 0 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 3px;
        }
        
        button:hover {
            background-color: #004400;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .control-button {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            padding: 0;
        }
        
        #scale-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            text-align: center;
            color: rgba(0, 255, 0, 0.8);
            z-index: 5;
        }
        
        .coordinate-axis {
            position: absolute;
            background-color: rgba(0, 255, 0, 0.2);
        }
        
        .x-axis {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-0.5px);
        }
        
        .z-axis {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            transform: translateX(-0.5px);
        }
        
        .coordinate-label {
            position: absolute;
            font-size: 10px;
            color: rgba(0, 255, 0, 0.7);
        }
        
        #altitude-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 10px;
            font-size: 12px;
            z-index: 100;
            width: auto;
            min-width: 150px;
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
        }
        
        .legend-color.altitude-low {
            background-color: #00ff00;
        }
        
        .legend-color.altitude-medium {
            background-color: #ffff00;
        }
        
        .legend-color.altitude-high {
            background-color: #ff00ff;
        }
        
        .legend-color.altitude-very-high {
            background-color: #00ffff;
        }
        
        .legend-label {
            color: rgba(0, 255, 0, 0.7);
        }
        
        #plane-list-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 250px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 10px;
            font-size: 14px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            display: none; /* Hidden by default, will be shown if screen is wide enough */
            z-index: 90;
            max-height: 60vh;
            overflow: hidden;
        }
        
        .plane-list-header {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: #00ff00;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            padding-bottom: 5px;
        }
        
        #plane-list {
            max-height: 55vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #001100;
        }
        
        #plane-list::-webkit-scrollbar {
            width: 6px;
        }
        
        #plane-list::-webkit-scrollbar-track {
            background: #001100;
        }
        
        #plane-list::-webkit-scrollbar-thumb {
            background-color: #00ff00;
            border-radius: 3px;
        }
        
        .plane-list-item {
            display: flex;
            align-items: center;
            padding: 3px 5px;
            margin-bottom: 3px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
            position: relative;
        }
        
        .plane-list-item:hover {
            background-color: rgba(0, 255, 0, 0.1);
        }
        
        .plane-list-item.selected {
            border-color: #ffff00;
            background-color: rgba(255, 255, 0, 0.1);
        }
        
        .plane-list-item.new-plane {
            animation: flash-green 1s;
        }
        
        @keyframes flash-green {
            0% { background-color: rgba(0, 255, 0, 0); }
            50% { background-color: rgba(0, 255, 0, 0.3); }
            100% { background-color: rgba(0, 255, 0, 0); }
        }
        
        .plane-list-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .plane-list-info {
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .plane-list-id {
            font-weight: bold;
        }
        
        .plane-list-time {
            font-size: 12px;
            color: rgba(0, 255, 0, 0.7);
            margin-left: 8px;
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 1300px) {
            #altitude-legend {
                display: none;
            }
            
            #controls {
                flex-wrap: wrap;
                max-width: 90%;
            }
            
            button {
                margin: 3px;
            }
        }
        
        @media (max-width: 768px) {
            #info-panel {
                top: auto;
                bottom: 0;
                right: 0;
                left: 0;
                width: calc(100% - 65px);
                border-radius: 0;
                border-width: 1px 0 0 0;
                margin: 20px;
            }
            
            #controls {
                bottom: 270px;
            }
            
            #scale-indicator {
                bottom: 160px;
            }
            
            #title-bar {
                width: calc(100% - 60px);
            }
        }
        
        @media (max-width: 500px) {
            /* Hide less essential buttons on very small screens */
            #controls, #center-runway, #center-carrier, #toggle-trails {
                display: none;
            }
            
            button {
                margin: 2px;
                padding: 4px 8px;
                font-size: 12px;
            }
        }
        
        .centering-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ffff00;
            transform: translate(-50%, -50%);
            animation: center-pulse 1s ease-out;
            pointer-events: none;
            z-index: 20;
        }
        
        @keyframes center-pulse {
            0% {
                width: 40px;
                height: 40px;
                opacity: 1;
                border-width: 2px;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
                border-width: 1px;
            }
        }
        
        /* Runway and carrier styles */
        .runway {
            position: absolute;
            width: 20px;
            height: 200px;
            background-color: rgba(0, 255, 0, 0.3);
            border: 1px solid rgba(0, 255, 0, 0.7);
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        
        .runway-label {
            position: absolute;
            color: rgba(0, 255, 0, 0.7);
            font-size: 12px;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            text-align: center;
        }
        
        .carrier {
            position: absolute;
            width: 40px;
            height: 120px;
            background-color: rgba(0, 255, 255, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.7);
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        
        .carrier-label {
            position: absolute;
            color: rgba(0, 255, 255, 0.7);
            font-size: 12px;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            text-align: center;
        }
        
        #help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #help-content {
            background-color: #222;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 20px;
            max-width: 400px;
            color: #fff;
        }
        
        #help-content h2 {
            margin-top: 0;
            color: #0f0;
        }
        
        #help-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        #help-content td {
            padding: 8px;
            border-bottom: 1px solid #444;
        }
        
        #help-content td:first-child {
            width: 80px;
            text-align: center;
        }
        
        kbd {
            background-color: #333;
            border: 1px solid #555;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(255,255,255,0.2);
            color: #fff;
            display: inline-block;
            font-size: 0.85em;
            padding: 2px 6px;
        }
        
        #close-help {
            background-color: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px 15px;
            border-radius: 3px;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }
        
        #close-help:hover {
            background-color: #444;
        }
        
        #show-help {
            background-color: #333;
            color: #fff;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="title-bar">
            <span>PieterFly ATC Visualizer</span>
            <button id="launch-button">Launch</button>
        </div>
        <div id="credits">
            <span>Made in </span>
            <video id="cursor-logo" autoplay loop muted playsinline>
                <source src="https://www.cursor.com/assets/images/logo.mp4" type="video/mp4">
            </video>
            <span class="clickable-text" id="cursor-link">Cursor</span>
            <span> by </span>
            <span class="clickable-text" id="dan-perks-link">Dan Perks</span>
        </div>
        
        <div id="radar">
            <div class="radar-sweep"></div>
            <!-- Radar circles will be added dynamically -->
            <div class="radar-center"></div>
            <div class="coordinate-axis x-axis"></div>
            <div class="coordinate-axis z-axis"></div>
            <div id="scale-indicator">Scale: <span id="scale-value">1000</span> units</div>
            <div id="runway" class="runway">
                <div class="runway-label">Runway</div>
            </div>
            <div id="carrier" class="carrier">
                <div class="carrier-label">Carrier</div>
            </div>
        </div>
        
        <div id="connection-status">Status: Connecting...</div>
        
        <div id="info-panel">
            <div class="info-row">
                <span class="info-label">Status:</span>
                <span class="info-value" id="connection-status-value">Connecting...</span>
            </div>
            <div class="info-row">
                <span class="info-label">Active Planes:</span>
                <span class="info-value" id="active-planes-count">0</span>
            </div>
            <div class="info-row">
                <span class="info-label">Last Update:</span>
                <span class="info-value" id="last-update-time">--:--:--</span>
            </div>
            
            <div id="selected-plane-info">
                <div class="info-row">
                    <span class="info-label">Selected:</span>
                    <span class="info-value" id="selected-plane-id">None</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Position:</span>
                    <span class="info-value" id="selected-plane-position">--</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Altitude:</span>
                    <span class="info-value" id="selected-plane-altitude">--</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Heading:</span>
                    <span class="info-value" id="selected-plane-heading">--</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Speed:</span>
                    <span class="info-value" id="selected-plane-speed">--</span>
                </div>
            </div>
        </div>
        
        <div id="controls">
            <button id="zoom-in" class="control-button">+</button>
            <button id="zoom-out" class="control-button">-</button>
            <button id="center-view">Center</button>
            <button id="center-runway">Runway</button>
            <button id="center-carrier">Carrier</button>
            <button id="deselect-plane" disabled>Deselect</button>
            <button id="toggle-landed">Show Landed</button>
        </div>
        
        <div id="plane-list-container">
            <div class="plane-list-header">Active Planes</div>
            <div id="plane-list"></div>
        </div>
        
        <div id="altitude-legend">
            <div class="legend-title">Altitude</div>
            <div class="legend-item">
                <div class="legend-color altitude-low"></div>
                <div class="legend-label">&lt; 3,300 ft <span style="font-size: 9px;">(planes &lt; 30ft hidden by default)</span></div>
            </div>
            <div class="legend-item">
                <div class="legend-color altitude-medium"></div>
                <div class="legend-label">3,300 - 10,000 ft</div>
            </div>
            <div class="legend-item">
                <div class="legend-color altitude-high"></div>
                <div class="legend-label">10,000 - 20,000 ft</div>
            </div>
            <div class="legend-item">
                <div class="legend-color altitude-very-high"></div>
                <div class="legend-label">&gt; 20,000 ft</div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Add bad word list at top of script
        const BAD_WORDS = [
            "nigger", "nigga", "n1gger", "n1gga", "negro", "n3gro", "n!gger", "n!gga",
            "faggot", "fag", "f4ggot", "f4g", "f@ggot", "f@g", "fagg0t", "f@gg0t",
            "chink", "gook", "spic", "kike", "kyke", "ch1nk", "g00k", "sp1c", "k1ke",
            "retard", "r3tard", "tard", "cunt", "r3t@rd", "ret@rd", "c*nt", "c@nt",
            "hitler", "nazi", "h1tler", "n4zi", "h!tler", "naz1", "n@zi", "h1tl3r",
            "rape", "r4pe", "rapist", "r4pist", "r@pe", "r@pist", "r@p1st", "r4p1st",
            "kill yourself", "kys", "suicide", "su1c1de", "k1ll yourself", "k!ll yourself",
            "whore", "slut", "bitch", "b1tch", "wh0re", "sl*t", "b!tch", "b*tch", "h0e", "hoe",
            "penis", "vagina", "pussy", "dick", "cock", "p3nis", "v@gina", "p*ssy", "d!ck", "c0ck",
            "cum", "jizz", "porn", "anal", "c*m", "j!zz", "p0rn", "@nal", "@nus",
            "blowjob", "bl0wjob", "handjob", "h@ndjob", "rimjob", "r1mjob",
            "dildo", "d1ldo", "vibrator", "v1brator", "buttplug", "buttp1ug",
            "orgasm", "0rgasm", "orgy", "0rgy", "gangbang", "g@ngbang",
            "masturbate", "m@sturbate", "jackoff", "j@ckoff", "wank", "w@nk",
            "asshole", "@sshole", "a$$hole", "a$$h0le", "a**hole", "a**h0le",
            "shit", "sh1t", "sh!t", "bullshit", "bullsh1t", "f*ck", "fuck", "fuk", "fucker", "f*cker",
            "motherfucker", "motherf*cker", "m0therf*cker", "m0therfucker",
            "tits", "t1ts", "boobs", "b00bs", "titties", "t1tties"
        ];

        // Add after other global variables
        let selfUsername = 'ATC Viewer';
        let selfPlaneId = generatePlaneId();

        // Connect to WebSocket server on page load
        document.getElementById('launch-button').addEventListener('click', function() {
            // Open fly.html directly
            window.open('https://fly.pieter.com', '_blank');
        });
        
        // Configuration
        const WS_SERVER = 'wss://fly.pieter.com:8080';
        const MAX_PLANES = 100;
        const TRAIL_LENGTH = 20;
        const TRAIL_INTERVAL = 1000; // Reduced from 2000ms to 1000ms for more frequent trail points
        const S = '7sw3hs9rmrmcq113'; // Server secret (must match the server's secret)
        const MAX_RECONNECT_ATTEMPTS = 10; // Maximum number of reconnection attempts
        
        let reconnectAttempts = 0;
        
        // Function to generate a unique plane ID
        function generatePlaneId() {
            // Generate a random string of letters and numbers
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            for (let i = 0; i < 6; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            console.log('âœˆï¸ My plane ID:', id);
            return id;
        }
        
        // Function to generate a secret key
        function generateSecretKey() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let key = '';
            for (let i = 0; i < 16; i++) {
                key += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return key;
        }
        
        // State variables
        let socket = null;
        let planes = new Map(); // Map of planeId -> plane data
        let selectedPlaneId = null;
        let scale = 1000; // Initial scale (radar radius in game units)
        let showTrails = true;
        let showLanded = false; // Default to hiding landed planes
        let autoCenter = true; // Auto-center on selected plane
        let radarCenter = { x: 0, z: 0 }; // Center of the radar view in game coordinates
        let lastUpdateTime = Date.now(); // Track last update time for auto-reconnect
        let lastHeartbeatTime = 0; // Track last heartbeat time
        let lastPlaneListUpdate = 0; // Track last plane list update time for debouncing
        let ourPlaneId = null; // Our plane ID for heartbeat messages
        let ourSecretKey = null; // Our secret key for heartbeat messages
        let verifyToken = null; // Our verification token from the server
        const NO_UPDATE_RECONNECT_TIMEOUT = 15000; // Reconnect if no updates for 5 seconds
        const PLANE_FADE_START = 5000; // Start fading plane after 5 seconds
        const PLANE_FADE_DURATION = 5000; // Complete fade over 5 seconds
        const HEARTBEAT_INTERVAL = 0.5; // Send heartbeat every 0.5 seconds (same as fly.html)
        const LANDED_ALTITUDE_THRESHOLD = 30; // Planes below this altitude (in feet) are considered landed
        const PLANE_LIST_UPDATE_INTERVAL = 1000; // Update plane list once per second
        
        // Runway and carrier coordinates from fly.html
        const RUNWAY_X = 0;
        const RUNWAY_Z = 90;
        const RUNWAY_LENGTH = 200;
        const RUNWAY_WIDTH = 20;
        
        const CARRIER_X = -600;
        const CARRIER_Z = 70;
        const CARRIER_LENGTH = 120;
        const CARRIER_WIDTH = 40;
        
        // DOM elements
        const radar = document.getElementById('radar');
        const connectionStatus = document.getElementById('connection-status');
        const connectionStatusValue = document.getElementById('connection-status-value');
        const activePlanesCount = document.getElementById('active-planes-count');
        const lastUpdateTimeElement = document.getElementById('last-update-time');
        const selectedPlaneIdElement = document.getElementById('selected-plane-id');
        const selectedPlanePosition = document.getElementById('selected-plane-position');
        const selectedPlaneAltitude = document.getElementById('selected-plane-altitude');
        const selectedPlaneHeading = document.getElementById('selected-plane-heading');
        const selectedPlaneSpeed = document.getElementById('selected-plane-speed');
        const scaleValue = document.getElementById('scale-value');
        const planeListContainer = document.getElementById('plane-list-container');
        const planeList = document.getElementById('plane-list');
        
        // Check if screen is wide enough to show the plane list
        function checkScreenWidth() {
            if (window.innerWidth > 1000) {
                planeListContainer.style.display = 'block';
            } else {
                planeListContainer.style.display = 'none';
            }
            
            // No need to manually handle altitude legend and controls here
            // as they're controlled by CSS media queries
        }
        
        // Call on load and on resize
        window.addEventListener('resize', checkScreenWidth);
        checkScreenWidth();
        
        // Create radar circles
        function createRadarCircles() {
            const circles = [0.25, 0.5, 0.75];
            circles.forEach(ratio => {
                const circle = document.createElement('div');
                circle.className = 'radar-circle';
                circle.style.width = `${ratio * 100}%`;
                circle.style.height = `${ratio * 100}%`;
                
                // Add coordinate labels
                const distance = Math.round(scale * ratio);
                
                // Top label (positive Z)
                const topLabel = document.createElement('div');
                topLabel.className = 'coordinate-label';
                topLabel.textContent = `${distance}`;
                topLabel.style.top = '5px';
                topLabel.style.left = '50%';
                topLabel.style.transform = 'translateX(-50%)';
                
                // Bottom label (negative Z)
                const bottomLabel = document.createElement('div');
                bottomLabel.className = 'coordinate-label';
                bottomLabel.textContent = `-${distance}`;
                bottomLabel.style.bottom = '5px';
                bottomLabel.style.left = '50%';
                bottomLabel.style.transform = 'translateX(-50%)';
                
                // Left label (positive X) - Changed from negative to positive
                const leftLabel = document.createElement('div');
                leftLabel.className = 'coordinate-label';
                leftLabel.textContent = `${distance}`; // Changed from -${distance} to ${distance}
                leftLabel.style.left = '5px';
                leftLabel.style.top = '50%';
                leftLabel.style.transform = 'translateY(-50%)';
                
                // Right label (negative X) - Changed from positive to negative
                const rightLabel = document.createElement('div');
                rightLabel.className = 'coordinate-label';
                rightLabel.textContent = `-${distance}`; // Changed from ${distance} to -${distance}
                rightLabel.style.right = '5px';
                rightLabel.style.top = '50%';
                rightLabel.style.transform = 'translateY(-50%)';
                
                radar.appendChild(circle);
                radar.appendChild(topLabel);
                radar.appendChild(bottomLabel);
                radar.appendChild(leftLabel);
                radar.appendChild(rightLabel);
            });
        }
        
        // Initialize radar circles
        createRadarCircles();
        
        // Update runway and carrier positions
        function updateLandingZones() {
            const runway = document.getElementById('runway');
            const carrier = document.getElementById('carrier');
            
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            
            // Calculate runway position relative to radar center and scale
            const runwayRelX = (RUNWAY_X - radarCenter.x) / scale;
            const runwayRelZ = (RUNWAY_Z - radarCenter.z) / scale;
            
            // Convert to screen coordinates
            const runwayScreenX = radarRadius * (1 - runwayRelX); // Changed from (1 + runwayRelX) to (1 - runwayRelX)
            const runwayScreenZ = radarRadius * (1 - runwayRelZ); // Invert Z axis
            
            // Update runway position
            runway.style.left = `${runwayScreenX}px`;
            runway.style.top = `${runwayScreenZ}px`;
            
            // Scale runway size based on radar scale
            const runwayScreenLength = (RUNWAY_LENGTH / scale) * radarRadius;
            const runwayScreenWidth = (RUNWAY_WIDTH / scale) * radarRadius;
            
            runway.style.height = `${runwayScreenLength}px`;
            runway.style.width = `${runwayScreenWidth}px`;
            
            // Calculate carrier position
            const carrierRelX = (CARRIER_X - radarCenter.x) / scale;
            const carrierRelZ = (CARRIER_Z - radarCenter.z) / scale;
            
            // Convert to screen coordinates
            const carrierScreenX = radarRadius * (1 - carrierRelX); // Changed from (1 + carrierRelX) to (1 - carrierRelX)
            const carrierScreenZ = radarRadius * (1 - carrierRelZ); // Invert Z axis
            
            // Update carrier position
            carrier.style.left = `${carrierScreenX}px`;
            carrier.style.top = `${carrierScreenZ}px`;
            
            // Scale carrier size based on radar scale
            const carrierScreenLength = (CARRIER_LENGTH / scale) * radarRadius;
            const carrierScreenWidth = (CARRIER_WIDTH / scale) * radarRadius;
            
            carrier.style.height = `${carrierScreenLength}px`;
            carrier.style.width = `${carrierScreenWidth}px`;
            
            // Hide runway and carrier if they're outside the radar view
            runway.style.display = (Math.abs(runwayRelX) > 1 || Math.abs(runwayRelZ) > 1) ? 'none' : 'block';
            carrier.style.display = (Math.abs(carrierRelX) > 1 || Math.abs(carrierRelZ) > 1) ? 'none' : 'block';
        }
        
        // Call updateLandingZones initially
        updateLandingZones();
        
        // Connect to WebSocket server
        function connectWebSocket() {
            try {
                console.log('Connecting to WebSocket server...');
                connectionStatus.textContent = 'Status: Connecting...';
                connectionStatusValue.textContent = 'Connecting...';
                connectionStatusValue.style.color = '#ffff00';
                
                socket = new WebSocket(WS_SERVER);
                
                socket.onopen = () => {
                    console.log('Connected to WebSocket server');
                    connectionStatus.textContent = 'Status: Connected';
                    connectionStatusValue.textContent = 'Connected';
                    connectionStatus.style.color = '#00ff00';
                    connectionStatusValue.style.color = '#00ff00';
                    
                    // Connect as an observer instead of simulating a plane
                    const message = {
                        type: 'observer',
                        secret: 'radar_screen_secret_key'
                    };
                    
                    console.log('Sending observer connection:', message);
                    socket.send(JSON.stringify(message));
                    
                    // No need to send heartbeats as an observer
                    // Reset lastHeartbeatTime
                    lastHeartbeatTime = Date.now();
                };
                
                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'position') {
                            // Handle single position update
                            handlePlaneData(data);
                            // Update last update time for auto-reconnect
                            lastUpdateTime = Date.now();
                        }
                        else if (data.type === 'positions') {
                            // Handle batch of position updates
                            if (data.data && Array.isArray(data.data)) {
                                data.data.forEach(positionData => {
                                    if (positionData.planeId) {
                                        const singleUpdate = {
                                            type: 'position',
                                            planeId: positionData.planeId,
                                            data: positionData
                                        };
                                        handlePlaneData(singleUpdate);
                                    }
                                });
                                // Update last update time for auto-reconnect
                                lastUpdateTime = Date.now();
                            }
                        }
                        // Handle crash events
                        else if (data.type === 'crash') {
                            console.log('ðŸ’¥ Crash event received:', data);
                            const crashedPlaneId = data.planeId;
                            const plane = planes.get(crashedPlaneId);

                            if (plane) {
                                // Optional: Add a visual effect for the crash
                                addCrashEffect(plane.position.x, plane.position.z);

                                // Remove the plane
                                removePlane(crashedPlaneId);

                                // Show a notification
                                const crashMessage = data.username ? `${data.username} ${data.verb || 'crashed'}` : `Plane ${crashedPlaneId} crashed`;
                                showNotification(crashMessage);
                            } else {
                                console.log(`Crash event for unknown plane: ${crashedPlaneId}`);
                            }
                        }
                        
                        // Update last update time
                        const now = new Date();
                        lastUpdateTimeElement.textContent = now.toLocaleTimeString();
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                        console.log('Raw message:', event.data);
                    }
                };
                
                socket.onclose = () => {
                    console.log('Disconnected from WebSocket server');
                    connectionStatus.textContent = 'Status: Disconnected';
                    connectionStatusValue.textContent = 'Disconnected';
                    connectionStatus.style.color = '#ff0000';
                    connectionStatusValue.style.color = '#ff0000';
                    
                    // Increment reconnect attempts
                    reconnectAttempts++;
                    
                    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                        console.log(`Failed to connect after ${MAX_RECONNECT_ATTEMPTS} attempts`);
                    } else {
                        console.log(`Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
                        // Try to reconnect after 5 seconds
                        setTimeout(connectWebSocket, 5000);
                    }
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    connectionStatus.textContent = 'Status: Error';
                    connectionStatusValue.textContent = 'Error';
                    connectionStatus.style.color = '#ff0000';
                    connectionStatusValue.style.color = '#ff0000';
                };
                
            } catch (error) {
                console.error('Failed to connect to WebSocket server:', error);
                connectionStatus.textContent = 'Status: Connection Failed';
                connectionStatusValue.textContent = 'Connection Failed';
                connectionStatus.style.color = '#ff0000';
                connectionStatusValue.style.color = '#ff0000';
                
                // Try to reconnect after 5 seconds
                setTimeout(connectWebSocket, 5000);
            }
        }
        
        // Handle incoming plane data
        function handlePlaneData(data) {
            if (data.type !== 'position' || !data.planeId) return;
            
            let positionData = data.data;
            
            // Check if we have position data in the expected format
            if (!positionData || (!positionData.x && !positionData.y && !positionData.z)) {
                // Try to find position data in data.data.position
                if (data.data && data.data.position) {
                    positionData = data.data.position;
                } else {
                    console.error('Could not find position data in:', data);
                    return;
                }
            }
            
            // Get or create plane data
            let plane = planes.get(data.planeId);
            
            if (!plane) {
                // Create new plane without visual element
                plane = {
                    id: data.planeId,
                    username: data.data.username || 'Anonymous Pilot', // Extract username from data or use default
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    speed: 0,
                    heading: 0,
                    verticalSpeed: 0,
                    lastUpdate: Date.now(),
                    creationTime: Date.now(),
                    element: null,
                    trails: [],
                    lastTrailTime: 0,
                    initialPosition: { x: positionData.x || 0, y: positionData.y || 0, z: positionData.z || 0 },
                    hasMoved: false
                };
                
                planes.set(data.planeId, plane);
            }
            
            // Update plane data
            if (positionData.username) plane.username = positionData.username;
            if (positionData.x !== undefined) plane.position.x = positionData.x;
            if (positionData.y !== undefined) plane.position.y = positionData.y;
            if (positionData.z !== undefined) plane.position.z = positionData.z;
            
            if (positionData.rotationX !== undefined) plane.rotation.x = positionData.rotationX;
            if (positionData.rotationY !== undefined) plane.rotation.y = positionData.rotationY;
            if (positionData.rotationZ !== undefined) plane.rotation.z = positionData.rotationZ;
            
            plane.speed = positionData.speed || 0;
            plane.heading = positionData.heading || 0;
            plane.verticalSpeed = positionData.verticalSpeed || 0;
            plane.lastUpdate = Date.now();
            
            // Check if the plane has moved from its initial position
            if (!plane.hasMoved) {
                const dx = plane.position.x - plane.initialPosition.x;
                const dy = plane.position.y - plane.initialPosition.y;
                const dz = plane.position.z - plane.initialPosition.z;
                
                // Calculate distance moved (squared to avoid sqrt for performance)
                const distanceSquared = dx*dx + dy*dy + dz*dz;
                
                // Consider the plane moved if it's moved more than 1 unit in any direction
                if (distanceSquared > 1) {
                    plane.hasMoved = true;
                    
                    // Create and add visual element now that the plane has moved
                    if (!plane.element) {
                        plane.element = createPlaneElement(plane.id);
                        if (plane.element) {  // Only append if element was created successfully
                            radar.appendChild(plane.element);
                        }
                    }
                }
            }
            
            // Add trail point if enough time has passed
            if (showTrails && Date.now() - plane.lastTrailTime > TRAIL_INTERVAL) {
                addTrailPoint(plane);
                plane.lastTrailTime = Date.now();
            }
            
            // Update plane position on radar
            updatePlanePosition(plane);
            
            // Update active planes count
            updateActivePlanesCount();
            
            // Update plane in the list if it has moved - let the debounced function handle this
            if (plane.hasMoved) {
                // Don't call updatePlaneListItem directly, let the interval handle it
                // This will be handled by the periodic updatePlaneList call
            }
            
            // Update selected plane info if this is the selected plane
            if (selectedPlaneId === plane.id) {
                updateSelectedPlaneInfo();
                
                // Keep selected plane centered as it moves if auto-center is enabled
                if (autoCenter) {
                    centerOnPlane(selectedPlaneId, false); // Don't show centering effect during auto-centering
                }
            }
        }
        
        // Create plane element
        function createPlaneElement(planeId) {
            const plane = planes.get(planeId);
            if (!plane) return null;

            const planeElement = document.createElement('div');
            planeElement.className = 'plane';
            planeElement.dataset.planeId = planeId;
            
            // Create SVG plane icon
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("viewBox", "0 0 24 24");
            svg.setAttribute("width", "20");
            svg.setAttribute("height", "20");
            svg.classList.add("plane-icon");
            
            // Create a triangle pointing upward (will be rotated based on heading)
            const path = document.createElementNS(svgNS, "path");
            path.setAttribute("d", "M12,2L20,20H4L12,2");
            svg.appendChild(path);
            
            // Create label
            const label = document.createElement('div');
            label.className = 'plane-label';
            label.textContent = plane.username || 'Anonymous Pilot';
            
            planeElement.appendChild(svg);
            planeElement.appendChild(label);
            
            // Add click event to select plane
            planeElement.addEventListener('click', () => {
                selectPlane(planeId);
            });
            
            return planeElement;
        }
        
        // Update plane position on radar
        function updatePlanePosition(plane) {
            // Skip planes that don't have visual elements yet
            if (!plane.element) return;
            
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            
            // Calculate position relative to radar center and scale
            const relX = (plane.position.x - radarCenter.x) / scale;
            const relZ = (plane.position.z - radarCenter.z) / scale;
            
            // Convert to screen coordinates (radar is a circle with radius = radarRadius)
            // FIX: Remove the inversion of the X axis by removing the "1 +" part
            const screenX = radarRadius * (1 - relX); // Changed from (1 + relX) to (1 - relX)
            const screenZ = radarRadius * (1 - relZ); // Invert Z axis to match game coordinates
            
            // Update plane element position
            plane.element.style.left = `${screenX}px`;
            plane.element.style.top = `${screenZ}px`;
            
            // Update altitude-based class
            const altitude = plane.position.y - 35.2; // Ground level is at 35.2
            plane.element.classList.remove('altitude-low', 'altitude-medium', 'altitude-high', 'altitude-very-high');
            
            if (altitude < 100) {
                plane.element.classList.add('altitude-low');
            } else if (altitude < 300) {
                plane.element.classList.add('altitude-medium');
            } else if (altitude < 600) {
                plane.element.classList.add('altitude-high');
            } else {
                plane.element.classList.add('altitude-very-high');
            }
            
            // Calculate opacity based on time since last update
            const timeSinceUpdate = Date.now() - plane.lastUpdate;
            let opacity = 1.0;
            
            // Only show planes that have moved from their initial position
            if (!plane.hasMoved) {
                opacity = 0; // Hide planes that haven't moved
            } 
            // Hide planes below 30ft unless showLanded is true
            else if (plane.position.y - 35.2 < LANDED_ALTITUDE_THRESHOLD && !showLanded) {
                opacity = 0; // Hide landed planes
            }
            else if (timeSinceUpdate > PLANE_FADE_START) {
                // Calculate fade progress (0 to 1)
                const fadeProgress = Math.min(1, (timeSinceUpdate - PLANE_FADE_START) / PLANE_FADE_DURATION);
                opacity = 1.0 - fadeProgress;
            }
            
            // Apply opacity to plane element
            plane.element.style.opacity = opacity;
            
            // Force a reflow to ensure CSS transitions are applied
            void plane.element.offsetWidth;
            
            // Update plane rotation (heading)
            const headingRad = (plane.heading * Math.PI) / 180;
            // Adjust rotation to make the triangle point in the direction of travel
            // The SVG triangle points up by default, so we need to rotate it
            // to match the game's coordinate system where 0 degrees is north (+Z).
            // Since the screen coordinates flip both X and Z relative to game coordinates,
            // the rotation needs to be negated.
            const rotationDeg = (-plane.heading) % 360; // Corrected rotation
            
            // Get the SVG element and rotate it
            const svg = plane.element.querySelector('.plane-icon');
            if (svg) {
                svg.style.transform = `rotate(${rotationDeg}deg)`;
            }
            
            // Update trail positions
            if (showTrails) {
                // Only show trails for the selected plane if one is selected
                const shouldShowTrails = !selectedPlaneId || selectedPlaneId === plane.id;
                
                plane.trails.forEach((trail, index) => {
                    const trailRelX = (trail.x - radarCenter.x) / scale;
                    const trailRelZ = (trail.z - radarCenter.z) / scale;
                    
                    const trailScreenX = radarRadius * (1 - trailRelX); // Changed from (1 + trailRelX) to (1 - trailRelX)
                    const trailScreenZ = radarRadius * (1 - trailRelZ);
                    
                    trail.element.style.left = `${trailScreenX}px`;
                    trail.element.style.top = `${trailScreenZ}px`;
                    
                    // Show/hide based on whether this is the selected plane
                    trail.element.style.display = shouldShowTrails ? 'block' : 'none';
                    
                    // Fade out older trails
                    const opacity = 0.5 * (1 - index / TRAIL_LENGTH);
                    trail.element.style.opacity = opacity;
                    
                    // Update line segment connecting to next point
                    if (index < plane.trails.length - 1 && trail.lineElement) {
                        const nextTrail = plane.trails[index + 1];
                        const nextTrailRelX = (nextTrail.x - radarCenter.x) / scale;
                        const nextTrailRelZ = (nextTrail.z - radarCenter.z) / scale;
                        
                        const nextTrailScreenX = radarRadius * (1 - nextTrailRelX);
                        const nextTrailScreenZ = radarRadius * (1 - nextTrailRelZ);
                        
                        // Calculate distance and angle between points
                        const dx = nextTrailScreenX - trailScreenX;
                        const dy = nextTrailScreenZ - trailScreenZ;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                        
                        // Position and rotate the line
                        trail.lineElement.style.left = `${trailScreenX}px`;
                        trail.lineElement.style.top = `${trailScreenZ}px`;
                        trail.lineElement.style.width = `${distance}px`;
                        trail.lineElement.style.transform = `rotate(${angle}deg)`;
                        trail.lineElement.style.opacity = opacity;
                        
                        // Show/hide based on whether this is the selected plane
                        trail.lineElement.style.display = shouldShowTrails ? 'block' : 'none';
                    }
                });
            }
        }
        
        // Add trail point for a plane
        function addTrailPoint(plane) {
            // Skip planes that don't have visual elements yet
            if (!plane.element) return;
            
            // Skip planes that are hidden (below altitude threshold or haven't moved)
            if (!plane.hasMoved) return;
            
            // Skip planes below altitude threshold unless showLanded is true
            const altitude = plane.position.y - 35.2;
            if (altitude < LANDED_ALTITUDE_THRESHOLD && !showLanded) return;
            
            const trailPoint = {
                x: plane.position.x,
                y: plane.position.y,
                z: plane.position.z,
                element: document.createElement('div'),
                lineElement: null,
                time: Date.now()
            };
            
            trailPoint.element.className = 'plane-trail';
            radar.appendChild(trailPoint.element);
            
            // Add to beginning of array
            plane.trails.unshift(trailPoint);
            
            // Create line segment between this point and the previous point if it exists
            if (plane.trails.length > 1) {
                const prevPoint = plane.trails[1];
                const lineElement = document.createElement('div');
                lineElement.className = 'trail-line';
                radar.appendChild(lineElement);
                
                // Store the line element with the current point
                trailPoint.lineElement = lineElement;
            }
            
            // Limit trail length
            if (plane.trails.length > TRAIL_LENGTH) {
                const removedTrail = plane.trails.pop();
                if (removedTrail.element.parentNode) {
                    removedTrail.element.parentNode.removeChild(removedTrail.element);
                }
                if (removedTrail.lineElement && removedTrail.lineElement.parentNode) {
                    removedTrail.lineElement.parentNode.removeChild(removedTrail.lineElement);
                }
            }
        }
        
        // Center on a specific plane
        function centerOnPlane(planeId, showEffect = true) {
            const plane = planes.get(planeId);
            if (plane) {
                radarCenter.x = plane.position.x;
                radarCenter.z = plane.position.z;
                
                // Add visual feedback only when requested (e.g., when clicked, not during auto-centering)
                if (showEffect) {
                    addCenteringEffect(plane.position.x, plane.position.z);
                }
                
                // Toggle visibility of the radar center dot
                const radarCenterDot = document.querySelector('.radar-center');
                if (radarCenterDot) {
                    radarCenterDot.style.display = 'none'; // Hide the center dot when a plane is centered
                }
                
                updateAllPlanePositions();
            }
        }
        
        // Select a plane
        function selectPlane(planeId) {
            // Deselect previously selected plane
            if (selectedPlaneId) {
                const prevPlane = planes.get(selectedPlaneId);
                if (prevPlane && prevPlane.element) {
                    prevPlane.element.style.border = 'none';
                }
                
                // Remove selected class from list item
                const prevListItem = document.getElementById(`plane-list-item-${selectedPlaneId}`);
                if (prevListItem) {
                    prevListItem.classList.remove('selected');
                }
            }
            
            selectedPlaneId = planeId;
            
            // Enable/disable center-selected button based on selection state
            document.getElementById('deselect-plane').disabled = !selectedPlaneId;
            
            // Highlight selected plane
            const plane = planes.get(planeId);
            if (plane && plane.element) {
                plane.element.style.border = '2px solid #ffff00';
                
                // Center the radar view on the selected plane
                centerOnPlane(planeId);
            }
            
            // Highlight list item
            const listItem = document.getElementById(`plane-list-item-${planeId}`);
            if (listItem) {
                listItem.classList.add('selected');
            }
            
            // Update selected plane info
            updateSelectedPlaneInfo();
            
            // Update all plane positions to refresh trail visibility
            updateAllPlanePositions();
        }
        
        // Add a visual feedback effect when centering on a plane
        function addCenteringEffect(x, z) {
            const effect = document.createElement('div');
            effect.className = 'centering-effect';
            radar.appendChild(effect);
            
            // Position the effect at the center of the radar
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            effect.style.left = `${radarRadius}px`;
            effect.style.top = `${radarRadius}px`;
            
            // Remove the effect after animation completes
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        }
        
        // Update selected plane info
        function updateSelectedPlaneInfo() {
            if (!selectedPlaneId) {
                selectedPlaneIdElement.textContent = 'None';
                selectedPlanePosition.textContent = '--';
                selectedPlaneAltitude.textContent = '--';
                selectedPlaneHeading.textContent = '--';
                selectedPlaneSpeed.textContent = '--';
                document.getElementById('deselect-plane').disabled = true;
                return;
            }
            
            const plane = planes.get(selectedPlaneId);
            if (!plane) {
                selectedPlaneIdElement.textContent = 'None';
                selectedPlanePosition.textContent = '--';
                selectedPlaneAltitude.textContent = '--';
                selectedPlaneHeading.textContent = '--';
                selectedPlaneSpeed.textContent = '--';
                document.getElementById('deselect-plane').disabled = true;
                selectedPlaneId = null;
                return;
            }
            
            document.getElementById('deselect-plane').disabled = false;
            selectedPlaneIdElement.textContent = plane.id;
            selectedPlanePosition.textContent = `X: ${Math.round(plane.position.x)}, Z: ${Math.round(plane.position.z)}`;
            
            // Convert Y position to feet (game units * 33.33)
            const altitudeFeet = Math.round((plane.position.y - 35.2) * 33.33);
            selectedPlaneAltitude.textContent = `${altitudeFeet} ft`;
            
            selectedPlaneHeading.textContent = `${Math.round(plane.heading)}Â°`;
            
            // Convert speed to km/h (game units * 525)
            const speedKmh = Math.round(plane.speed * 525);
            selectedPlaneSpeed.textContent = `${speedKmh} km/h`;
        }
        
        // Update active planes count
        function updateActivePlanesCount() {
            const now = Date.now();
            // Remove activeCount variable, we'll just use planes.size
            const planesToRemove = []; // Keep track of planes to remove

            planes.forEach((plane, planeId) => {
                const timeSinceUpdate = now - plane.lastUpdate;
                const isVisible = plane.hasMoved && (showLanded || (plane.position.y - 35.2 >= LANDED_ALTITUDE_THRESHOLD));

                // Check if plane should be removed (stale or hidden and old)
                if (timeSinceUpdate > PLANE_FADE_START + PLANE_FADE_DURATION) {
                    planesToRemove.push(planeId);
                } else if (!isVisible && timeSinceUpdate > 15000) { // Remove hidden planes after 15s
                    planesToRemove.push(planeId);
                } else if (!plane.hasMoved && timeSinceUpdate > PLANE_FADE_START + PLANE_FADE_DURATION * 2) { // Remove unmoved planes after longer timeout
                    planesToRemove.push(planeId);
                }
                // No need to count active planes separately anymore
            });

            // Remove planes marked for removal
            planesToRemove.forEach(planeId => {
                removePlane(planeId); // removePlane already updates the count via planes.size
            });

            // Directly update the count to the current size of the planes map
            activePlanesCount.textContent = planes.size;
        }

        // Helper function to remove a plane completely
        function removePlane(planeId) {
            const plane = planes.get(planeId);
            if (!plane) return;

            // Remove plane element if it exists
            if (plane.element && plane.element.parentNode) {
                plane.element.parentNode.removeChild(plane.element);
            }

            // Remove trail elements
            plane.trails.forEach(trail => {
                if (trail.element && trail.element.parentNode) {
                    trail.element.parentNode.removeChild(trail.element);
                }
                if (trail.lineElement && trail.lineElement.parentNode) {
                    trail.lineElement.parentNode.removeChild(trail.lineElement);
                }
            });

            // Remove from planes map
            planes.delete(planeId);

            // Remove from plane list UI
            const listItem = document.getElementById(`plane-list-item-${planeId}`);
            if (listItem) {
                listItem.remove();
            }

            // If this was the selected plane, clear selection
            if (selectedPlaneId === planeId) {
                selectedPlaneId = null;
                updateSelectedPlaneInfo();
                // Show the radar center dot again
                const radarCenterDot = document.querySelector('.radar-center');
                if (radarCenterDot) {
                    radarCenterDot.style.display = 'block';
                }
            }

            // Update active count immediately after removal
            activePlanesCount.textContent = planes.size;
            console.log(`Removed plane ${planeId}`);
        }

        // Update all planes positions
        function updateAllPlanePositions() {
            planes.forEach(plane => {
                updatePlanePosition(plane);
            });
            
            // Also update runway and carrier positions
            updateLandingZones();
        }
        
        // Zoom in button
        document.getElementById('zoom-in').addEventListener('click', () => {
            scale = Math.max(scale / 1.5, 100);
            scaleValue.textContent = scale;
            updateRadarCircles();
            updateAllPlanePositions();
        });
        
        // Zoom out button
        document.getElementById('zoom-out').addEventListener('click', () => {
            scale = Math.min(scale * 1.5, 5000);
            scaleValue.textContent = scale;
            updateRadarCircles();
            updateAllPlanePositions();
        });
        
        // Center view button
        document.getElementById('center-view').addEventListener('click', () => {
            if (selectedPlaneId) {
                // If a plane is selected, center on that plane
                centerOnPlane(selectedPlaneId);
            } else {
                // If no plane is selected, center the map
                radarCenter = { x: 0, z: 0 };
                
                // Show the radar center dot again
                const radarCenterDot = document.querySelector('.radar-center');
                if (radarCenterDot) {
                    radarCenterDot.style.display = 'block';
                }
                
                updateAllPlanePositions();
            }
        });
        
        // Center on runway button
        document.getElementById('center-runway').addEventListener('click', () => {
            radarCenter = { x: RUNWAY_X, z: RUNWAY_Z };
            updateAllPlanePositions();
            
            // Show the radar center dot again
            const radarCenterDot = document.querySelector('.radar-center');
            if (radarCenterDot) {
                radarCenterDot.style.display = 'block';
            }
            
            // Add visual feedback
            const effect = document.createElement('div');
            effect.className = 'centering-effect';
            radar.appendChild(effect);
            
            // Position the effect at the runway position
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            const runwayScreenX = radarRadius;
            const runwayScreenZ = radarRadius;
            effect.style.left = `${runwayScreenX}px`;
            effect.style.top = `${runwayScreenZ}px`;
            
            // Remove the effect after animation completes
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        });
        
        // Center on carrier button
        document.getElementById('center-carrier').addEventListener('click', () => {
            radarCenter = { x: CARRIER_X, z: CARRIER_Z };
            updateAllPlanePositions();
            
            // Show the radar center dot again
            const radarCenterDot = document.querySelector('.radar-center');
            if (radarCenterDot) {
                radarCenterDot.style.display = 'block';
            }
            
            // Add visual feedback
            const effect = document.createElement('div');
            effect.className = 'centering-effect';
            radar.appendChild(effect);
            
            // Position the effect at the carrier position
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            const carrierScreenX = radarRadius;
            const carrierScreenZ = radarRadius;
            effect.style.left = `${carrierScreenX}px`;
            effect.style.top = `${carrierScreenZ}px`;
            
            // Remove the effect after animation completes
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        });
        
        // Deselect plane button
        document.getElementById('deselect-plane').addEventListener('click', () => {
            if (selectedPlaneId) {
                // Deselect the plane
                const plane = planes.get(selectedPlaneId);
                if (plane && plane.element) {
                    plane.element.style.border = 'none';
                }
                
                // Remove selected class from list item
                const listItem = document.getElementById(`plane-list-item-${selectedPlaneId}`);
                if (listItem) {
                    listItem.classList.remove('selected');
                }
                
                // Show the radar center dot again
                const radarCenterDot = document.querySelector('.radar-center');
                if (radarCenterDot) {
                    radarCenterDot.style.display = 'block';
                }
                
                // Clear selection
                selectedPlaneId = null;
                updateSelectedPlaneInfo();
                
                // Update all plane positions to refresh trail visibility
                updateAllPlanePositions();
            }
        });
        
        // Toggle landed button
        document.getElementById('toggle-landed').addEventListener('click', () => {
            showLanded = !showLanded;
            document.getElementById('toggle-landed').textContent = showLanded ? 'Hide Landed' : 'Show Landed';
            
            // Update all plane visibilities
            updateAllPlanePositions();
            
            // Force an immediate update of the plane list
            lastPlaneListUpdate = 0;
            updatePlaneList();
        });
        
        // Update radar circles when scale changes
        function updateRadarCircles() {
            // Remove existing circles and labels
            const existingCircles = document.querySelectorAll('.radar-circle, .coordinate-label');
            existingCircles.forEach(element => element.remove());
            
            // Create new circles with updated scale
            createRadarCircles();
        }
        
        // Function to check if selected plane is far from center and deselect if needed
        function checkAndDeselectPlane() {
            if (selectedPlaneId) {
                const plane = planes.get(selectedPlaneId);
                if (plane) {
                    // Calculate distance between plane position and radar center
                    const dx = plane.position.x - radarCenter.x;
                    const dz = plane.position.z - radarCenter.z;
                    
                    // Calculate distance as a percentage of the radar radius
                    const distancePercentage = Math.sqrt(dx*dx + dz*dz) / scale;
                    
                    // If the plane is more than 30% away from the center, deselect it
                    if (distancePercentage > 0.3) {
                        // Deselect the plane
                        if (plane.element) {
                            plane.element.style.border = 'none';
                        }
                        
                        // Remove selected class from list item
                        const listItem = document.getElementById(`plane-list-item-${selectedPlaneId}`);
                        if (listItem) {
                            listItem.classList.remove('selected');
                        }
                        
                        // Show the radar center dot again
                        const radarCenterDot = document.querySelector('.radar-center');
                        if (radarCenterDot) {
                            radarCenterDot.style.display = 'block';
                        }
                        
                        // Clear selection
                        selectedPlaneId = null;
                        updateSelectedPlaneInfo();
                        
                        // Update all plane positions to refresh trail visibility
                        updateAllPlanePositions();
                        
                        return true; // Plane was deselected
                    }
                }
            }
            return false; // No deselection occurred
        }

        // Drag functionality for panning the radar view
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartCenterX = 0;
        let dragStartCenterZ = 0;
        
        radar.addEventListener('mousedown', (event) => {
            isDragging = true;
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            dragStartCenterX = radarCenter.x;
            dragStartCenterZ = radarCenter.z;
            radar.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            
            const deltaX = event.clientX - dragStartX;
            const deltaY = event.clientY - dragStartY;
            
            // Convert screen delta to game coordinates
            const gameUnitDeltaX = (deltaX / radarRadius) * scale;
            const gameUnitDeltaZ = (deltaY / radarRadius) * scale;
            
            // Update radar center (invert Z axis)
            radarCenter.x = dragStartCenterX + gameUnitDeltaX; // Changed from - to + to match the new orientation
            radarCenter.z = dragStartCenterZ + gameUnitDeltaZ;
            
            // Update all plane positions
            updateAllPlanePositions();
            
            // Check if selected plane is far from center and deselect if needed
            checkAndDeselectPlane();
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            radar.style.cursor = 'default';
        });
        
        // Mouse wheel zoom
        radar.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            if (event.deltaY < 0) {
                // Zoom in
                scale = Math.max(scale / 1.1, 100);
            } else {
                // Zoom out
                scale = Math.min(scale * 1.1, 5000);
            }
            
            scaleValue.textContent = Math.round(scale);
            updateRadarCircles();
            updateAllPlanePositions();
            
            // Check if selected plane is far from center and deselect if needed
            checkAndDeselectPlane();
        });
        
        // Periodically check for inactive planes
        setInterval(() => {
            updateActivePlanesCount();
        }, 1000); // Check every second (was 5000)
        
        // Check for server connection status and auto-reconnect if needed
        setInterval(() => {
            const timeSinceLastUpdate = Date.now() - lastUpdateTime;
            
            // Update connection status with time since last update
            const seconds = Math.floor(timeSinceLastUpdate / 1000);
            if (socket && socket.readyState === WebSocket.OPEN) {
                connectionStatus.textContent = `Status: Connected`;
                connectionStatusValue.textContent = 'Connected';
                
                // Change color based on time since last update
                if (seconds > 4) {
                    connectionStatus.style.color = '#ffaa00'; // Yellow warning
                    connectionStatusValue.style.color = '#ffaa00';
                } else {
                    connectionStatus.style.color = '#00ff00'; // Green normal
                    connectionStatusValue.style.color = '#00ff00';
                }
            }
            
            // If no updates received within timeout period, reconnect
            if (timeSinceLastUpdate > NO_UPDATE_RECONNECT_TIMEOUT) {
                console.log(`No updates received for ${timeSinceLastUpdate}ms, reconnecting...`);
                
                // Only reconnect if socket is open (to avoid reconnecting during reconnection)
                if (socket && socket.readyState === WebSocket.OPEN) {
                    connectionStatus.textContent = 'Status: Auto-reconnecting...';
                    connectionStatusValue.textContent = 'Auto-reconnecting...';
                    connectionStatus.style.color = '#ffaa00';
                    connectionStatusValue.style.color = '#ffaa00';
                    
                    // Close current connection
                    socket.close();
                    
                    // Reset reconnect attempts
                    reconnectAttempts = 0;
                    
                    // Try to reconnect
                    setTimeout(connectWebSocket, 1000);
                }
                
                // Update last update time to prevent multiple reconnects
                lastUpdateTime = Date.now();
            }
        }, 1000); // Check every second
        
        // Send heartbeat regularly to keep the connection alive
        setInterval(() => {
            sendHeartbeat();
        }, 100); // Check frequently, but sendHeartbeat has its own rate limiting
        
        // Send heartbeat to keep the connection alive
        function sendHeartbeat() {
            // No need to send heartbeats when connected as an observer
            return;
            
            /*
            if (!socket || socket.readyState !== WebSocket.OPEN || !ourPlaneId) {
                return;
            }
            
            const currentTime = Date.now();
            if (currentTime - lastHeartbeatTime < HEARTBEAT_INTERVAL * 1000) {
                return;
            }
            
            // Create a position with small random variations to simulate activity
            // Keep the ATC position near the center of the map but with small variations
            const positionData = {
                x: Math.round((Math.random() * 10 - 5) * 100) / 100, // Small random position near center
                y: Math.round((36 + Math.random() * 5) * 100) / 100, // Just above ground level with small variation
                z: Math.round((Math.random() * 10 - 5) * 100) / 100, // Small random position near center
                rotationX: Math.round((Math.random() * 0.1) * 100) / 100,
                rotationY: Math.round((Math.random() * 0.1) * 100) / 100,
                rotationZ: Math.round((Math.random() * 0.1) * 100) / 100,
                speed: Math.round(0.01 + Math.random() * 0.05), // Very slow speed
                heading: Math.round((Date.now() / 1000) % 360), // Slowly rotating heading
                verticalSpeed: Math.round((Math.random() * 0.01 - 0.005) * 100) / 100, // Small random vertical speed
                timestamp: currentTime,
                username: 'ATC Viewer' // Fixed username instead of from localStorage
            };
            
            const message = {
                type: 'position',
                planeId: ourPlaneId,
                data: positionData,
                username: 'ATC Viewer',
                verifyToken: verifyToken
            };
            
            // Log heartbeat occasionally (only once every ~5 minutes)
            if (Math.random() < 0.0001) {
                console.log('Sending heartbeat:', message);
            }
            
            try {
                socket.send(JSON.stringify(message));
                lastHeartbeatTime = currentTime;
            } catch (err) {
                console.error('âŒ Failed to send heartbeat:', err);
            }
            */
        }
        
        // Periodically update all plane positions and opacities
        function updateAllPlanesOpacity() {
            planes.forEach(plane => {
                // Skip planes that don't have visual elements yet
                if (!plane.element) return;
                
                // Calculate opacity based on time since last update
                const timeSinceUpdate = Date.now() - plane.lastUpdate;
                let opacity = 1.0;
                
                // Only show planes that have moved from their initial position
                if (!plane.hasMoved) {
                    opacity = 0; // Hide planes that haven't moved
                } 
                // Hide planes below 30ft unless showLanded is true
                else if (plane.position.y - 35.2 < LANDED_ALTITUDE_THRESHOLD && !showLanded) {
                    opacity = 0; // Hide landed planes
                }
                else if (timeSinceUpdate > PLANE_FADE_START) {
                    // Calculate fade progress (0 to 1)
                    const fadeProgress = Math.min(1, (timeSinceUpdate - PLANE_FADE_START) / PLANE_FADE_DURATION);
                    opacity = 1.0 - fadeProgress;
                }
                
                // Apply opacity to plane element
                plane.element.style.opacity = opacity;
            });
            
            // Request next frame
            requestAnimationFrame(updateAllPlanesOpacity);
        }
        
        // Start the continuous update loop
        requestAnimationFrame(updateAllPlanesOpacity);
        
        // Connect to WebSocket server on page load
        window.addEventListener('load', () => {
            // Make a POST request to the hit counter API
            // Nothing neferious, just to see how it's doing!
            fetch('https://danperks.dev/api/hits/atc', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    timestamp: Date.now()
                })
            })
            
            // Connect to WebSocket server immediately
            connectWebSocket();
            
            // Set initial button text for toggle-landed
            document.getElementById('toggle-landed').textContent = showLanded ? 'Hide Landed' : 'Show Landed';
            
            // Check if screen is wide enough for plane list
            checkScreenWidth();
            
            // Initialize plane list with existing planes
            updatePlaneList();
            
            // Set up periodic plane list updates
            setInterval(updatePlaneList, PLANE_LIST_UPDATE_INTERVAL);
            
            // Add event listener for launch button
            document.getElementById('launch-button').addEventListener('click', () => {
                window.open('https://fly.pieter.com', '_blank');
            });
            
            // Add event listeners for clickable text elements
            document.getElementById('cursor-link').addEventListener('click', () => {
                window.open('https://cursor.com', '_blank');
            });
            
            document.getElementById('dan-perks-link').addEventListener('click', () => {
                window.open('https://danperks.dev', '_blank');
            });
        });
        
        // Update plane list with current planes
        function updatePlaneList() {
            // Only update if the plane list is visible
            if (planeListContainer.style.display !== 'block') return;
            
            // Debounce updates to once per second
            const now = Date.now();
            if (now - lastPlaneListUpdate < PLANE_LIST_UPDATE_INTERVAL) return;
            lastPlaneListUpdate = now;
            
            // Get all planes sorted by creation time (oldest first)
            const sortedPlanes = Array.from(planes.values())
                .filter(plane => {
                    // Only show planes that have moved
                    if (!plane.hasMoved) return false;
                    
                    // We now show all planes that have moved, regardless of altitude
                    return true;
                })
                .sort((a, b) => a.creationTime - b.creationTime); // Sort by creation time, oldest first
            
            // Update each plane in the list
            sortedPlanes.forEach(plane => {
                updatePlaneListItem(plane, true); // Pass true to indicate this is a batch update
            });
            
            // Remove list items for planes that haven't moved
            const listItems = planeList.querySelectorAll('.plane-list-item');
            listItems.forEach(item => {
                const itemPlaneId = item.id.replace('plane-list-item-', '');
                const plane = planes.get(itemPlaneId);
                
                if (!plane || !plane.hasMoved) {
                    item.remove();
                }
            });
        }
        
        // Update or create a plane list item
        function updatePlaneListItem(plane, isBatchUpdate = false) {
            // Only update if the plane list is visible
            if (planeListContainer.style.display !== 'block') return;
            
            // Check if the plane should be visible
            if (!plane.hasMoved) return;
            
            // If not a batch update, apply debouncing
            if (!isBatchUpdate) {
                const now = Date.now();
                if (now - lastPlaneListUpdate < PLANE_LIST_UPDATE_INTERVAL) return;
                lastPlaneListUpdate = now;
            }
            
            const planeId = plane.id;
            let listItem = document.getElementById(`plane-list-item-${planeId}`);
            const isNewItem = !listItem;
            
            // Check if the plane is below altitude threshold (will be marked as hidden)
            const altitude = plane.position.y - 35.2;
            const isHidden = altitude < LANDED_ALTITUDE_THRESHOLD && !showLanded;
            
            // If the plane doesn't have a list item yet, create one
            if (isNewItem) {
                listItem = document.createElement('div');
                listItem.id = `plane-list-item-${planeId}`;
                listItem.className = 'plane-list-item new-plane';
                
                // Censor plane ID if longer than 6 characters
                const displayName = plane.username || 'Anonymous Pilot';
                const hiddenIndicator = isHidden ? ' (hidden)' : '';
                
                listItem.innerHTML = `
                    <div class="plane-list-color"></div>
                    <div class="plane-list-info">
                        <div class="plane-list-id">${displayName}${hiddenIndicator}</div>
                        <div class="plane-list-time">0s</div>
                    </div>
                `;
                
                // Add click event to select the plane
                listItem.addEventListener('click', () => {
                    selectPlane(planeId);
                });
                
                // Add to the list based on creation time
                let inserted = false;
                const items = planeList.querySelectorAll('.plane-list-item');
                for (let i = 0; i < items.length; i++) {
                    const itemId = items[i].id.replace('plane-list-item-', '');
                    const existingPlane = planes.get(itemId);
                    if (existingPlane && existingPlane.creationTime > plane.creationTime) {
                        planeList.insertBefore(listItem, items[i]);
                        inserted = true;
                        break;
                    }
                }
                
                if (!inserted) {
                    planeList.appendChild(listItem);
                }
                
                // Remove the new-plane class after animation completes
                setTimeout(() => {
                    listItem.classList.remove('new-plane');
                }, 1000);
            } else {
                // Update the hidden indicator if needed
                const nameElement = listItem.querySelector('.plane-list-id');
                // Add null check here
                if (nameElement) {
                    const displayName = plane.username || 'Anonymous Pilot';
                    const altitude = plane.position.y - 35.2; // Need altitude to determine hidden status
                    const isHidden = altitude < LANDED_ALTITUDE_THRESHOLD && !showLanded;
                    const hiddenIndicator = isHidden ? ' (hidden)' : '';
                    nameElement.textContent = `${displayName}${hiddenIndicator}`;
                }
            }
            
            // Update the color based on altitude
            const colorElement = listItem.querySelector('.plane-list-color');
            
            if (altitude < 30 && !showLanded) {
                // Landed planes (only visible when showLanded is true)
                colorElement.style.backgroundColor = '#555555';
            } else if (altitude < 100) {
                colorElement.style.backgroundColor = '#00ff00'; // Green for low altitude
            } else if (altitude < 300) {
                colorElement.style.backgroundColor = '#ffff00'; // Yellow for medium altitude
            } else if (altitude < 600) {
                colorElement.style.backgroundColor = '#ff00ff'; // Magenta for high altitude
            } else {
                colorElement.style.backgroundColor = '#00ffff'; // Cyan for very high altitude
            }
            
            // Update the time since creation
            const existenceTime = Math.floor((Date.now() - plane.creationTime) / 1000);
            listItem.querySelector('.plane-list-time').textContent = `${existenceTime}s`;
            
            // Highlight if selected
            if (selectedPlaneId === planeId) {
                listItem.classList.add('selected');
            } else {
                listItem.classList.remove('selected');
            }
        }
        
        
        // Update plane list times periodically
        function updatePlaneListTimes() {
            // Only update if the plane list is visible
            if (planeListContainer.style.display !== 'block') return;

            const now = Date.now();

            // Update the time for each plane in the list
            planes.forEach(plane => {
                if (plane.hasMoved) {
                    const listItem = document.getElementById(`plane-list-item-${plane.id}`);
                    if (listItem) {
                        const timeElement = listItem.querySelector('.plane-list-time');
                        const nameElement = listItem.querySelector('.plane-list-id'); // Query for name element here as well

                        // Check if timeElement exists before setting textContent
                        if (timeElement) {
                            const existenceTime = Math.floor((now - plane.creationTime) / 1000);
                            timeElement.textContent = `${existenceTime}s`; // Use the checked timeElement variable
                        } else {
                            // console.warn(`Could not find .plane-list-time for ${plane.id}`);
                        }

                        // Check if nameElement exists before setting textContent
                        if (nameElement) {
                            const altitude = plane.position.y - 35.2;
                            const isHidden = altitude < LANDED_ALTITUDE_THRESHOLD && !showLanded;
                            const displayName = plane.username || 'Anonymous Pilot';
                            const hiddenIndicator = isHidden ? ' (hidden)' : '';
                            nameElement.textContent = `${displayName}${hiddenIndicator}`; // Use the checked nameElement variable
                        } else {
                            // console.warn(`Could not find .plane-list-id for ${plane.id}`);
                        }
                    }
                }
            });
        }

        // Add crash effect function
        function addCrashEffect(x, z) {
            const effect = document.createElement('div');
            effect.className = 'centering-effect'; // Reuse centering effect style for now
            effect.style.borderColor = '#ff0000'; // Red color for crash
            radar.appendChild(effect);

            // Position the effect at the crash location
            const radarRect = radar.getBoundingClientRect();
            const radarRadius = radarRect.width / 2;
            const relX = (x - radarCenter.x) / scale;
            const relZ = (z - radarCenter.z) / scale;
            const screenX = radarRadius * (1 - relX);
            const screenZ = radarRadius * (1 - relZ);
            effect.style.left = `${screenX}px`;
            effect.style.top = `${screenZ}px`;

            // Remove the effect after animation completes
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        }

        // Add notification function
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            // Remove the notification after a few seconds
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }
    </script>
</body>
</html>
